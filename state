kernel/bio.c:47:    b->next = bcache.head.next;
kernel/bio.c:48:    b->prev = &bcache.head;
kernel/bio.c:49:    initsleeplock(&b->lock, "buffer");
kernel/bio.c:50:    bcache.head.next->prev = b;
kernel/bio.c:66:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
kernel/bio.c:67:    if(b->dev == dev && b->blockno == blockno){
kernel/bio.c:68:      b->refcnt++;
kernel/bio.c:70:      acquiresleep(&b->lock);
kernel/bio.c:77:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
kernel/bio.c:78:    if(b->refcnt == 0) {
kernel/bio.c:79:      b->dev = dev;
kernel/bio.c:80:      b->blockno = blockno;
kernel/bio.c:81:      b->valid = 0;
kernel/bio.c:82:      b->refcnt = 1;
kernel/bio.c:84:      acquiresleep(&b->lock);
kernel/bio.c:98:  if(!b->valid) {
kernel/bio.c:100:    b->valid = 1;
kernel/bio.c:109:  if(!holdingsleep(&b->lock))
kernel/bio.c:115:// Move to the head of the most-recently-used list.
kernel/bio.c:119:  if(!holdingsleep(&b->lock))
kernel/bio.c:122:  releasesleep(&b->lock);
kernel/bio.c:125:  b->refcnt--;
kernel/bio.c:126:  if (b->refcnt == 0) {
kernel/bio.c:128:    b->next->prev = b->prev;
kernel/bio.c:129:    b->prev->next = b->next;
kernel/bio.c:130:    b->next = bcache.head.next;
kernel/bio.c:131:    b->prev = &bcache.head;
kernel/bio.c:132:    bcache.head.next->prev = b;
kernel/bio.c:142:  b->refcnt++;
kernel/bio.c:149:  b->refcnt--;
kernel/console.c:5://   newline -- end of line
kernel/console.c:6://   control-h -- backspace
kernel/console.c:7://   control-u -- kill line
kernel/console.c:8://   control-d -- end of file
kernel/console.c:9://   control-p -- print process list
kernel/console.c:26:#define C(x)  ((x)-'@')  // Control-x
kernel/console.c:65:    if(either_copyin(&c, user_src, src+i, 1) == -1)
kernel/console.c:92:      if(myproc()->killed){
kernel/console.c:94:        return -1;
kernel/console.c:101:    if(c == C('D')){  // end-of-file
kernel/console.c:104:        // caller gets a 0-byte result.
kernel/console.c:105:        cons.r--;
kernel/console.c:110:    // copy the input byte to the user-space buffer.
kernel/console.c:112:    if(either_copyout(user_dst, dst, &cbuf, 1) == -1)
kernel/console.c:116:    --n;
kernel/console.c:120:      // the user-level read().
kernel/console.c:126:  return target - n;
kernel/console.c:146:          cons.buf[(cons.e-1) % INPUT_BUF] != '\n'){
kernel/console.c:147:      cons.e--;
kernel/console.c:154:      cons.e--;
kernel/console.c:159:    if(c != 0 && cons.e-cons.r < INPUT_BUF){
kernel/console.c:169:        // wake up consoleread() if a whole line (or end-of-file)
kernel/defs.h:185:// number of elements in fixed-size array
kernel/exec.c:28:    return -1;
kernel/exec.c:65:  uint64 oldsz = p->sz;
kernel/exec.c:74:  uvmclear(pagetable, sz-2*PGSIZE);
kernel/exec.c:76:  stackbase = sp - PGSIZE;
kernel/exec.c:82:    sp -= strlen(argv[argc]) + 1;
kernel/exec.c:83:    sp -= sp % 16; // riscv sp must be 16-byte aligned
kernel/exec.c:93:  sp -= (argc+1) * sizeof(uint64);
kernel/exec.c:94:  sp -= sp % 16;
kernel/exec.c:103:  p->trapframe->a1 = sp;
kernel/exec.c:109:  safestrcpy(p->name, last, sizeof(p->name));
kernel/exec.c:112:  oldpagetable = p->pagetable;
kernel/exec.c:113:  p->pagetable = pagetable;
kernel/exec.c:114:  p->sz = sz;
kernel/exec.c:115:  p->trapframe->epc = elf.entry;  // initial program counter = main
kernel/exec.c:116:  p->trapframe->sp = sp; // initial stack pointer
kernel/exec.c:128:  return -1;
kernel/exec.c:132:// va must be page-aligned
kernel/exec.c:134:// Returns 0 on success, -1 on failure.
kernel/exec.c:145:    if(sz - i < PGSIZE)
kernel/exec.c:146:      n = sz - i;
kernel/exec.c:150:      return -1;
kernel/file.c:36:    if(f->ref == 0){
kernel/file.c:37:      f->ref = 1;
kernel/file.c:51:  if(f->ref < 1)
kernel/file.c:53:  f->ref++;
kernel/file.c:65:  if(f->ref < 1)
kernel/file.c:67:  if(--f->ref > 0){
kernel/file.c:72:  f->ref = 0;
kernel/file.c:73:  f->type = FD_NONE;
kernel/file.c:93:  if(f->type == FD_INODE || f->type == FD_DEVICE){
kernel/file.c:94:    ilock(f->ip);
kernel/file.c:95:    stati(f->ip, &st);
kernel/file.c:96:    iunlock(f->ip);
kernel/file.c:97:    if(copyout(p->pagetable, addr, (char *)&st, sizeof(st)) < 0)
kernel/file.c:98:      return -1;
kernel/file.c:101:  return -1;
kernel/file.c:111:  if(f->readable == 0)
kernel/file.c:112:    return -1;
kernel/file.c:114:  if(f->type == FD_PIPE){
kernel/file.c:115:    r = piperead(f->pipe, addr, n);
kernel/file.c:116:  } else if(f->type == FD_DEVICE){
kernel/file.c:117:    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].read)
kernel/file.c:118:      return -1;
kernel/file.c:119:    r = devsw[f->major].read(1, addr, n);
kernel/file.c:120:  } else if(f->type == FD_INODE){
kernel/file.c:121:    ilock(f->ip);
kernel/file.c:122:    if((r = readi(f->ip, 1, addr, f->off, n)) > 0)
kernel/file.c:123:      f->off += r;
kernel/file.c:124:    iunlock(f->ip);
kernel/file.c:139:  if(f->writable == 0)
kernel/file.c:140:    return -1;
kernel/file.c:142:  if(f->type == FD_PIPE){
kernel/file.c:143:    ret = pipewrite(f->pipe, addr, n);
kernel/file.c:144:  } else if(f->type == FD_DEVICE){
kernel/file.c:145:    if(f->major < 0 || f->major >= NDEV || !devsw[f->major].write)
kernel/file.c:146:      return -1;
kernel/file.c:147:    ret = devsw[f->major].write(1, addr, n);
kernel/file.c:148:  } else if(f->type == FD_INODE){
kernel/file.c:151:    // i-node, indirect block, allocation blocks,
kernel/file.c:152:    // and 2 blocks of slop for non-aligned writes.
kernel/file.c:155:    int max = ((MAXOPBLOCKS-1-1-2) / 2) * BSIZE;
kernel/file.c:158:      int n1 = n - i;
kernel/file.c:163:      ilock(f->ip);
kernel/file.c:164:      if ((r = writei(f->ip, 1, addr + i, f->off, n1)) > 0)
kernel/file.c:165:        f->off += r;
kernel/file.c:166:      iunlock(f->ip);
kernel/file.c:175:    ret = (i == n ? n : -1);
kernel/file.h:16:// in-memory copy of an inode
kernel/fs.c:3://   + Log: crash recovery for multi-step updates.
kernel/fs.c:8:// This file contains the low-level file system manipulation
kernel/fs.c:9:// routines.  The (higher-level) system call implementations
kernel/fs.c:36:  memmove(sb, bp->data, sizeof(*sb));
kernel/fs.c:56:  memset(bp->data, 0, BSIZE);
kernel/fs.c:75:      if((bp->data[bi/8] & m) == 0){  // Is block free?
kernel/fs.c:76:        bp->data[bi/8] |= m;  // Mark block in use.
kernel/fs.c:98:  if((bp->data[bi/8] & m) == 0)
kernel/fs.c:100:  bp->data[bi/8] &= ~m;
kernel/fs.c:116:// The kernel keeps a table of in-use inodes in memory
kernel/fs.c:118:// to inodes used by multiple processes. The in-memory
kernel/fs.c:119:// inodes include book-keeping information that is
kernel/fs.c:120:// not stored on disk: ip->ref and ip->valid.
kernel/fs.c:122:// An inode and its in-memory representation go through a
kernel/fs.c:127://   is non-zero. ialloc() allocates, and iput() frees if
kernel/fs.c:131://   is free if ip->ref is zero. Otherwise ip->ref tracks
kernel/fs.c:132://   the number of in-memory pointers to the entry (open
kernel/fs.c:138://   table entry is only correct when ip->valid is 1.
kernel/fs.c:140://   the disk and sets ip->valid, while iput() clears
kernel/fs.c:141://   ip->valid if ip->ref has fallen to zero.
kernel/fs.c:150://   ... examine and modify ip->xxx ...
kernel/fs.c:155:// get a long-term reference to an inode (as for an open file)
kernel/fs.c:158:// pathname lookup. iget() increments ip->ref so that the inode
kernel/fs.c:163:// multi-step atomic operations.
kernel/fs.c:165:// The itable.lock spin-lock protects the allocation of itable
kernel/fs.c:166:// entries. Since ip->ref indicates whether an entry is free,
kernel/fs.c:167:// and ip->dev and ip->inum indicate which i-node an entry
kernel/fs.c:170:// An ip->lock sleep-lock protects all ip-> fields other than ref,
kernel/fs.c:171:// dev, and inum.  One must hold ip->lock in order to
kernel/fs.c:172:// read or write that inode's ip->valid, ip->size, ip->type, &c.
kernel/fs.c:204:    dip = (struct dinode*)bp->data + inum%IPB;
kernel/fs.c:205:    if(dip->type == 0){  // a free inode
kernel/fs.c:207:      dip->type = type;
kernel/fs.c:217:// Copy a modified in-memory inode to disk.
kernel/fs.c:218:// Must be called after every change to an ip->xxx field
kernel/fs.c:220:// Caller must hold ip->lock.
kernel/fs.c:227:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:228:  dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:229:  dip->type = ip->type;
kernel/fs.c:230:  dip->major = ip->major;
kernel/fs.c:231:  dip->minor = ip->minor;
kernel/fs.c:232:  dip->nlink = ip->nlink;
kernel/fs.c:233:  dip->size = ip->size;
kernel/fs.c:234:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
kernel/fs.c:240:// and return the in-memory copy. Does not lock
kernel/fs.c:252:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
kernel/fs.c:253:      ip->ref++;
kernel/fs.c:257:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
kernel/fs.c:266:  ip->dev = dev;
kernel/fs.c:267:  ip->inum = inum;
kernel/fs.c:268:  ip->ref = 1;
kernel/fs.c:269:  ip->valid = 0;
kernel/fs.c:281:  ip->ref++;
kernel/fs.c:294:  if(ip == 0 || ip->ref < 1)
kernel/fs.c:297:  acquiresleep(&ip->lock);
kernel/fs.c:299:  if(ip->valid == 0){
kernel/fs.c:300:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
kernel/fs.c:301:    dip = (struct dinode*)bp->data + ip->inum%IPB;
kernel/fs.c:302:    ip->type = dip->type;
kernel/fs.c:303:    ip->major = dip->major;
kernel/fs.c:304:    ip->minor = dip->minor;
kernel/fs.c:305:    ip->nlink = dip->nlink;
kernel/fs.c:306:    ip->size = dip->size;
kernel/fs.c:307:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
kernel/fs.c:309:    ip->valid = 1;
kernel/fs.c:310:    if(ip->type == 0)
kernel/fs.c:319:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
kernel/fs.c:322:  releasesleep(&ip->lock);
kernel/fs.c:325:// Drop a reference to an in-memory inode.
kernel/fs.c:337:  if(ip->ref == 1 && ip->valid && ip->nlink == 0){
kernel/fs.c:340:    // ip->ref == 1 means no other process can have ip locked,
kernel/fs.c:342:    acquiresleep(&ip->lock);
kernel/fs.c:347:    ip->type = 0;
kernel/fs.c:349:    ip->valid = 0;
kernel/fs.c:351:    releasesleep(&ip->lock);
kernel/fs.c:356:  ip->ref--;
kernel/fs.c:372:// are listed in ip->addrs[].  The next NINDIRECT blocks are
kernel/fs.c:373:// listed in block ip->addrs[NDIRECT].
kernel/fs.c:384:    if((addr = ip->addrs[bn]) == 0)
kernel/fs.c:385:      ip->addrs[bn] = addr = balloc(ip->dev);
kernel/fs.c:388:  bn -= NDIRECT;
kernel/fs.c:392:    if((addr = ip->addrs[NDIRECT]) == 0)
kernel/fs.c:393:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
kernel/fs.c:394:    bp = bread(ip->dev, addr);
kernel/fs.c:395:    a = (uint*)bp->data;
kernel/fs.c:397:      a[bn] = addr = balloc(ip->dev);
kernel/fs.c:408:// Caller must hold ip->lock.
kernel/fs.c:417:    if(ip->addrs[i]){
kernel/fs.c:418:      bfree(ip->dev, ip->addrs[i]);
kernel/fs.c:419:      ip->addrs[i] = 0;
kernel/fs.c:423:  if(ip->addrs[NDIRECT]){
kernel/fs.c:424:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:425:    a = (uint*)bp->data;
kernel/fs.c:428:        bfree(ip->dev, a[j]);
kernel/fs.c:431:    bfree(ip->dev, ip->addrs[NDIRECT]);
kernel/fs.c:432:    ip->addrs[NDIRECT] = 0;
kernel/fs.c:435:  ip->size = 0;
kernel/fs.c:440:// Caller must hold ip->lock.
kernel/fs.c:444:  st->dev = ip->dev;
kernel/fs.c:445:  st->ino = ip->inum;
kernel/fs.c:446:  st->type = ip->type;
kernel/fs.c:447:  st->nlink = ip->nlink;
kernel/fs.c:448:  st->size = ip->size;
kernel/fs.c:452:// Caller must hold ip->lock.
kernel/fs.c:461:  if(off > ip->size || off + n < off)
kernel/fs.c:463:  if(off + n > ip->size)
kernel/fs.c:464:    n = ip->size - off;
kernel/fs.c:467:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:468:    m = min(n - tot, BSIZE - off%BSIZE);
kernel/fs.c:469:    if(either_copyout(user_dst, dst, bp->data + (off % BSIZE), m) == -1) {
kernel/fs.c:471:      tot = -1;
kernel/fs.c:480:// Caller must hold ip->lock.
kernel/fs.c:492:  if(off > ip->size || off + n < off)
kernel/fs.c:493:    return -1;
kernel/fs.c:495:    return -1;
kernel/fs.c:498:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
kernel/fs.c:499:    m = min(n - tot, BSIZE - off%BSIZE);
kernel/fs.c:500:    if(either_copyin(bp->data + (off % BSIZE), user_src, src, m) == -1) {
kernel/fs.c:508:  if(off > ip->size)
kernel/fs.c:509:    ip->size = off;
kernel/fs.c:511:  // write the i-node back to disk even if the size didn't change
kernel/fs.c:513:  // block to ip->addrs[].
kernel/fs.c:535:  if(dp->type != T_DIR)
kernel/fs.c:538:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/fs.c:548:      return iget(dp->dev, inum);
kernel/fs.c:566:    return -1;
kernel/fs.c:570:  for(off = 0; off < dp->size; off += sizeof(de)){
kernel/fs.c:612:  len = path - s;
kernel/fs.c:636:    ip = idup(myproc()->cwd);
kernel/fs.c:640:    if(ip->type != T_DIR){
kernel/fs.h:1:// On-disk file system format.
kernel/fs.h:5:#define ROOTINO  1   // root i-number
kernel/fs.h:31:// On-disk inode structure
kernel/kalloc.c:2:// kernel stacks, page-table pages,
kernel/kalloc.c:3:// and pipe buffers. Allocates whole 4096-byte pages.
kernel/kalloc.c:60:  r->next = kmem.freelist;
kernel/kalloc.c:65:// Allocate one 4096-byte page of physical memory.
kernel/kalloc.c:76:    kmem.freelist = r->next;
kernel/log.c:20:// the count of in-progress FS system calls and returns.
kernel/log.c:24:// The log is a physical re-do log containing disk blocks.
kernel/log.c:25:// The on-disk log format:
kernel/log.c:33:// Contents of the header block, used for both the on-disk header block
kernel/log.c:61:  log.start = sb->logstart;
kernel/log.c:62:  log.size = sb->nlog;
kernel/log.c:76:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
kernel/log.c:85:// Read the log header from disk into the in-memory log header
kernel/log.c:90:  struct logheader *lh = (struct logheader *) (buf->data);
kernel/log.c:92:  log.lh.n = lh->n;
kernel/log.c:94:    log.lh.block[i] = lh->block[i];
kernel/log.c:99:// Write in-memory log header to disk.
kernel/log.c:106:  struct logheader *hb = (struct logheader *) (buf->data);
kernel/log.c:108:  hb->n = log.lh.n;
kernel/log.c:110:    hb->block[i] = log.lh.block[i];
kernel/log.c:152:  log.outstanding -= 1;
kernel/log.c:186:    memmove(to->data, from->data, BSIZE);
kernel/log.c:198:    write_head();    // Write header to disk -- the real commit
kernel/log.c:205:// Caller has modified b->data and is done with the buffer.
kernel/log.c:211://   modify bp->data[]
kernel/log.c:220:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
kernel/log.c:226:    if (log.lh.block[i] == b->blockno)   // log absorption
kernel/log.c:229:  log.lh.block[i] = b->blockno;
kernel/memlayout.h:3:// qemu -machine virt is set up like this,
kernel/memlayout.h:6:// 00001000 -- boot ROM, provided by qemu
kernel/memlayout.h:7:// 02000000 -- CLINT
kernel/memlayout.h:8:// 0C000000 -- PLIC
kernel/memlayout.h:9:// 10000000 -- uart0 
kernel/memlayout.h:10:// 10001000 -- virtio disk 
kernel/memlayout.h:11:// 80000000 -- boot ROM jumps here in machine mode
kernel/memlayout.h:12://             -kernel loads the kernel here
kernel/memlayout.h:16:// 80000000 -- entry.S, then kernel text and data
kernel/memlayout.h:17:// end -- start of kernel page allocation area
kernel/memlayout.h:18:// PHYSTOP -- end RAM used by the kernel
kernel/memlayout.h:33:// qemu puts platform-level interrupt controller (PLIC) here.
kernel/memlayout.h:52:#define TRAMPOLINE (MAXVA - PGSIZE)
kernel/memlayout.h:56:#define KSTACK(p) (TRAMPOLINE - ((p)+1)* 2*PGSIZE)
kernel/memlayout.h:62://   fixed-size stack
kernel/memlayout.h:65://   TRAPFRAME (p->trapframe, used by the trampoline)
kernel/memlayout.h:67:#define TRAPFRAME (TRAMPOLINE - PGSIZE)
kernel/param.h:5:#define NINODE       50  // maximum number of active i-nodes
kernel/param.h:10:#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
kernel/pipe.c:33:  pi->readopen = 1;
kernel/pipe.c:34:  pi->writeopen = 1;
kernel/pipe.c:35:  pi->nwrite = 0;
kernel/pipe.c:36:  pi->nread = 0;
kernel/pipe.c:37:  initlock(&pi->lock, "pipe");
kernel/pipe.c:38:  (*f0)->type = FD_PIPE;
kernel/pipe.c:39:  (*f0)->readable = 1;
kernel/pipe.c:40:  (*f0)->writable = 0;
kernel/pipe.c:41:  (*f0)->pipe = pi;
kernel/pipe.c:42:  (*f1)->type = FD_PIPE;
kernel/pipe.c:43:  (*f1)->readable = 0;
kernel/pipe.c:44:  (*f1)->writable = 1;
kernel/pipe.c:45:  (*f1)->pipe = pi;
kernel/pipe.c:55:  return -1;
kernel/pipe.c:61:  acquire(&pi->lock);
kernel/pipe.c:63:    pi->writeopen = 0;
kernel/pipe.c:64:    wakeup(&pi->nread);
kernel/pipe.c:66:    pi->readopen = 0;
kernel/pipe.c:67:    wakeup(&pi->nwrite);
kernel/pipe.c:69:  if(pi->readopen == 0 && pi->writeopen == 0){
kernel/pipe.c:70:    release(&pi->lock);
kernel/pipe.c:73:    release(&pi->lock);
kernel/pipe.c:82:  acquire(&pi->lock);
kernel/pipe.c:84:    if(pi->readopen == 0 || pr->killed){
kernel/pipe.c:85:      release(&pi->lock);
kernel/pipe.c:86:      return -1;
kernel/pipe.c:88:    if(pi->nwrite == pi->nread + PIPESIZE){ //DOC: pipewrite-full
kernel/pipe.c:89:      wakeup(&pi->nread);
kernel/pipe.c:90:      sleep(&pi->nwrite, &pi->lock);
kernel/pipe.c:93:      if(copyin(pr->pagetable, &ch, addr + i, 1) == -1)
kernel/pipe.c:95:      pi->data[pi->nwrite++ % PIPESIZE] = ch;
kernel/pipe.c:99:  wakeup(&pi->nread);
kernel/pipe.c:100:  release(&pi->lock);
kernel/pipe.c:112:  acquire(&pi->lock);
kernel/pipe.c:113:  while(pi->nread == pi->nwrite && pi->writeopen){  //DOC: pipe-empty
kernel/pipe.c:114:    if(pr->killed){
kernel/pipe.c:115:      release(&pi->lock);
kernel/pipe.c:116:      return -1;
kernel/pipe.c:118:    sleep(&pi->nread, &pi->lock); //DOC: piperead-sleep
kernel/pipe.c:120:  for(i = 0; i < n; i++){  //DOC: piperead-copy
kernel/pipe.c:121:    if(pi->nread == pi->nwrite)
kernel/pipe.c:123:    ch = pi->data[pi->nread++ % PIPESIZE];
kernel/pipe.c:124:    if(copyout(pr->pagetable, addr + i, &ch, 1) == -1)
kernel/pipe.c:127:  wakeup(&pi->nwrite);  //DOC: piperead-wakeup
kernel/pipe.c:128:  release(&pi->lock);
kernel/plic.c:14:  // set desired IRQ priorities non-zero (otherwise disabled).
kernel/plic.c:24:  // set uart's enable bit for this hart's S-mode. 
kernel/plic.c:27:  // set this hart's S-mode priority threshold to 0.
kernel/printf.c:2:// formatted console output -- printf, panic.
kernel/printf.c:36:    x = -xx;
kernel/printf.c:46:    buf[i++] = '-';
kernel/printf.c:48:  while(--i >= 0)
kernel/printf.c:59:    consputc(digits[x >> (sizeof(uint64) * 8 - 4)]);
kernel/proc.c:25:// memory model when using p->parent.
kernel/proc.c:26:// must be acquired before any p->lock.
kernel/proc.c:40:    uint64 va = KSTACK((int) (p - proc));
kernel/proc.c:54:      initlock(&p->lock, "proc");
kernel/proc.c:55:      p->kstack = KSTACK((int) (p - proc));
kernel/proc.c:83:  struct proc *p = c->proc;
kernel/proc.c:102:// and return with p->lock held.
kernel/proc.c:110:    acquire(&p->lock);
kernel/proc.c:111:    if(p->state == UNUSED) {
kernel/proc.c:114:      release(&p->lock);
kernel/proc.c:120:  p->pid = allocpid();
kernel/proc.c:121:  p->state = USED;
kernel/proc.c:124:  if((p->trapframe = (struct trapframe *)kalloc()) == 0){
kernel/proc.c:126:    release(&p->lock);
kernel/proc.c:131:  p->pagetable = proc_pagetable(p);
kernel/proc.c:132:  if(p->pagetable == 0){
kernel/proc.c:134:    release(&p->lock);
kernel/proc.c:140:  memset(&p->context, 0, sizeof(p->context));
kernel/proc.c:141:  p->context.ra = (uint64)forkret;
kernel/proc.c:142:  p->context.sp = p->kstack + PGSIZE;
kernel/proc.c:149:// p->lock must be held.
kernel/proc.c:153:  if(p->trapframe)
kernel/proc.c:154:    kfree((void*)p->trapframe);
kernel/proc.c:155:  p->trapframe = 0;
kernel/proc.c:156:  if(p->pagetable)
kernel/proc.c:157:    proc_freepagetable(p->pagetable, p->sz);
kernel/proc.c:158:  p->pagetable = 0;
kernel/proc.c:159:  p->sz = 0;
kernel/proc.c:160:  p->pid = 0;
kernel/proc.c:161:  p->parent = 0;
kernel/proc.c:162:  p->name[0] = 0;
kernel/proc.c:163:  p->chan = 0;
kernel/proc.c:164:  p->killed = 0;
kernel/proc.c:165:  p->xstate = 0;
kernel/proc.c:166:  p->state = UNUSED;
kernel/proc.c:193:              (uint64)(p->trapframe), PTE_R | PTE_W) < 0){
kernel/proc.c:213:// od -t xC initcode
kernel/proc.c:235:  uvminit(p->pagetable, initcode, sizeof(initcode));
kernel/proc.c:236:  p->sz = PGSIZE;
kernel/proc.c:239:  p->trapframe->epc = 0;      // user program counter
kernel/proc.c:240:  p->trapframe->sp = PGSIZE;  // user stack pointer
kernel/proc.c:242:  safestrcpy(p->name, "initcode", sizeof(p->name));
kernel/proc.c:243:  p->cwd = namei("/");
kernel/proc.c:245:  p->state = RUNNABLE;
kernel/proc.c:247:  release(&p->lock);
kernel/proc.c:251:// Return 0 on success, -1 on failure.
kernel/proc.c:258:  sz = p->sz;
kernel/proc.c:260:    if((sz = uvmalloc(p->pagetable, sz, sz + n)) == 0) {
kernel/proc.c:261:      return -1;
kernel/proc.c:264:    sz = uvmdealloc(p->pagetable, sz, sz + n);
kernel/proc.c:266:  p->sz = sz;
kernel/proc.c:281:    return -1;
kernel/proc.c:285:  if(uvmcopy(p->pagetable, np->pagetable, p->sz) < 0){
kernel/proc.c:287:    release(&np->lock);
kernel/proc.c:288:    return -1;
kernel/proc.c:290:  np->sz = p->sz;
kernel/proc.c:293:  *(np->trapframe) = *(p->trapframe);
kernel/proc.c:296:  np->trapframe->a0 = 0;
kernel/proc.c:300:    if(p->ofile[i])
kernel/proc.c:301:      np->ofile[i] = filedup(p->ofile[i]);
kernel/proc.c:302:  np->cwd = idup(p->cwd);
kernel/proc.c:304:  safestrcpy(np->name, p->name, sizeof(p->name));
kernel/proc.c:306:  pid = np->pid;
kernel/proc.c:308:  release(&np->lock);
kernel/proc.c:311:  np->parent = p;
kernel/proc.c:314:  acquire(&np->lock);
kernel/proc.c:315:  np->state = RUNNABLE;
kernel/proc.c:316:  release(&np->lock);
kernel/proc.c:329:    if(pp->parent == p){
kernel/proc.c:330:      pp->parent = initproc;
kernel/proc.c:349:    if(p->ofile[fd]){
kernel/proc.c:350:      struct file *f = p->ofile[fd];
kernel/proc.c:352:      p->ofile[fd] = 0;
kernel/proc.c:357:  iput(p->cwd);
kernel/proc.c:359:  p->cwd = 0;
kernel/proc.c:367:  wakeup(p->parent);
kernel/proc.c:369:  acquire(&p->lock);
kernel/proc.c:371:  p->xstate = status;
kernel/proc.c:372:  p->state = ZOMBIE;
kernel/proc.c:382:// Return -1 if this process has no children.
kernel/proc.c:396:      if(np->parent == p){
kernel/proc.c:398:        acquire(&np->lock);
kernel/proc.c:401:        if(np->state == ZOMBIE){
kernel/proc.c:403:          pid = np->pid;
kernel/proc.c:404:          if(addr != 0 && copyout(p->pagetable, addr, (char *)&np->xstate,
kernel/proc.c:405:                                  sizeof(np->xstate)) < 0) {
kernel/proc.c:406:            release(&np->lock);
kernel/proc.c:408:            return -1;
kernel/proc.c:411:          release(&np->lock);
kernel/proc.c:415:        release(&np->lock);
kernel/proc.c:420:    if(!havekids || p->killed){
kernel/proc.c:422:      return -1;
kernel/proc.c:426:    sleep(p, &wait_lock);  //DOC: wait-sleep
kernel/proc.c:430:// Per-CPU process scheduler.
kernel/proc.c:433://  - choose a process to run.
kernel/proc.c:434://  - swtch to start running that process.
kernel/proc.c:435://  - eventually that process transfers control
kernel/proc.c:443:  c->proc = 0;
kernel/proc.c:449:      acquire(&p->lock);
kernel/proc.c:450:      if(p->state == RUNNABLE) {
kernel/proc.c:454:        p->state = RUNNING;
kernel/proc.c:455:        c->proc = p;
kernel/proc.c:456:        swtch(&c->context, &p->context);
kernel/proc.c:459:        // It should have changed its p->state before coming back.
kernel/proc.c:460:        c->proc = 0;
kernel/proc.c:462:      release(&p->lock);
kernel/proc.c:467:// Switch to scheduler.  Must hold only p->lock
kernel/proc.c:468:// and have changed proc->state. Saves and restores
kernel/proc.c:471:// be proc->intena and proc->noff, but that would
kernel/proc.c:480:  if(!holding(&p->lock))
kernel/proc.c:481:    panic("sched p->lock");
kernel/proc.c:482:  if(mycpu()->noff != 1)
kernel/proc.c:484:  if(p->state == RUNNING)
kernel/proc.c:489:  intena = mycpu()->intena;
kernel/proc.c:490:  swtch(&p->context, &mycpu()->context);
kernel/proc.c:491:  mycpu()->intena = intena;
kernel/proc.c:499:  acquire(&p->lock);
kernel/proc.c:500:  p->state = RUNNABLE;
kernel/proc.c:502:  release(&p->lock);
kernel/proc.c:512:  // Still holding p->lock from scheduler.
kernel/proc.c:513:  release(&myproc()->lock);
kernel/proc.c:533:  // Must acquire p->lock in order to
kernel/proc.c:534:  // change p->state and then call sched.
kernel/proc.c:535:  // Once we hold p->lock, we can be
kernel/proc.c:537:  // (wakeup locks p->lock),
kernel/proc.c:540:  acquire(&p->lock);  //DOC: sleeplock1
kernel/proc.c:544:  p->chan = chan;
kernel/proc.c:545:  p->state = SLEEPING;
kernel/proc.c:550:  p->chan = 0;
kernel/proc.c:553:  release(&p->lock);
kernel/proc.c:558:// Must be called without any p->lock.
kernel/proc.c:566:      acquire(&p->lock);
kernel/proc.c:567:      if(p->state == SLEEPING && p->chan == chan) {
kernel/proc.c:568:        p->state = RUNNABLE;
kernel/proc.c:570:      release(&p->lock);
kernel/proc.c:584:    acquire(&p->lock);
kernel/proc.c:585:    if(p->pid == pid){
kernel/proc.c:586:      p->killed = 1;
kernel/proc.c:587:      if(p->state == SLEEPING){
kernel/proc.c:589:        p->state = RUNNABLE;
kernel/proc.c:591:      release(&p->lock);
kernel/proc.c:594:    release(&p->lock);
kernel/proc.c:596:  return -1;
kernel/proc.c:601:// Returns 0 on success, -1 on error.
kernel/proc.c:607:    return copyout(p->pagetable, dst, src, len);
kernel/proc.c:616:// Returns 0 on success, -1 on error.
kernel/proc.c:622:    return copyin(p->pagetable, dst, src, len);
kernel/proc.c:647:    if(p->state == UNUSED)
kernel/proc.c:649:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
kernel/proc.c:650:      state = states[p->state];
kernel/proc.c:653:    printf("%d %s %s", p->pid, state, p->name);
kernel/proc.h:6:  // callee-saved
kernel/proc.h:21:// Per-CPU state.
kernel/proc.h:31:// per-process data for the trap handling code in trampoline.S.
kernel/proc.h:41:// the trapframe includes callee-saved user registers like s0-s11 because the
kernel/proc.h:42:// return-to-user path via usertrapret() doesn't return through
kernel/proc.h:85:// Per-process state
kernel/proc.h:89:  // p->lock must be held when using these:
kernel/proc.h:91:  void *chan;                  // If non-zero, sleeping on chan
kernel/proc.h:92:  int killed;                  // If non-zero, have been killed
kernel/proc.h:101:  // these are private to the process, so p->lock need not be held.
kernel/ramdisk.c:2:// ramdisk that uses the disk image loaded by qemu -initrd fs.img
kernel/ramdisk.c:25:  if(!holdingsleep(&b->lock))
kernel/ramdisk.c:27:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
kernel/ramdisk.c:30:  if(b->blockno >= FSSIZE)
kernel/ramdisk.c:33:  uint64 diskaddr = b->blockno * BSIZE;
kernel/ramdisk.c:36:  if(b->flags & B_DIRTY){
kernel/ramdisk.c:38:    memmove(addr, b->data, BSIZE);
kernel/ramdisk.c:39:    b->flags &= ~B_DIRTY;
kernel/ramdisk.c:42:    memmove(b->data, addr, BSIZE);
kernel/ramdisk.c:43:    b->flags |= B_VALID;
kernel/riscv.h:16:#define MSTATUS_MIE (1L << 3)    // machine-mode interrupt enable.
kernel/riscv.h:96:// Machine-mode Interrupt Enable
kernel/riscv.h:161:// Supervisor Trap-Vector Base Address
kernel/riscv.h:177:// Machine-mode interrupt vector
kernel/riscv.h:248:// Machine-mode Counter-Enable
kernel/riscv.h:263:// machine-mode cycle counter
kernel/riscv.h:338:#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
kernel/riscv.h:339:#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
kernel/riscv.h:345:#define PTE_U (1L << 4) // 1 -> user can access
kernel/riscv.h:354:// extract the three 9-bit page table indices from a virtual address.
kernel/riscv.h:361:// Sv39, to avoid having to sign-extend virtual addresses
kernel/riscv.h:363:#define MAXVA (1L << (9 + 9 + 9 + 12 - 1))
kernel/sleeplock.c:15:  initlock(&lk->lk, "sleep lock");
kernel/sleeplock.c:16:  lk->name = name;
kernel/sleeplock.c:17:  lk->locked = 0;
kernel/sleeplock.c:18:  lk->pid = 0;
kernel/sleeplock.c:24:  acquire(&lk->lk);
kernel/sleeplock.c:25:  while (lk->locked) {
kernel/sleeplock.c:26:    sleep(lk, &lk->lk);
kernel/sleeplock.c:28:  lk->locked = 1;
kernel/sleeplock.c:29:  lk->pid = myproc()->pid;
kernel/sleeplock.c:30:  release(&lk->lk);
kernel/sleeplock.c:36:  acquire(&lk->lk);
kernel/sleeplock.c:37:  lk->locked = 0;
kernel/sleeplock.c:38:  lk->pid = 0;
kernel/sleeplock.c:40:  release(&lk->lk);
kernel/sleeplock.c:48:  acquire(&lk->lk);
kernel/sleeplock.c:49:  r = lk->locked && (lk->pid == myproc()->pid);
kernel/sleeplock.c:50:  release(&lk->lk);
kernel/sleeplock.h:1:// Long-term locks for processes
kernel/spinlock.c:14:  lk->name = name;
kernel/spinlock.c:15:  lk->locked = 0;
kernel/spinlock.c:16:  lk->cpu = 0;
kernel/spinlock.c:28:  // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
kernel/spinlock.c:30:  //   s1 = &lk->locked
kernel/spinlock.c:32:  while(__sync_lock_test_and_set(&lk->locked, 1) != 0)
kernel/spinlock.c:38:  // On RISC-V, this emits a fence instruction.
kernel/spinlock.c:42:  lk->cpu = mycpu();
kernel/spinlock.c:52:  lk->cpu = 0;
kernel/spinlock.c:59:  // On RISC-V, this emits a fence instruction.
kernel/spinlock.c:62:  // Release the lock, equivalent to lk->locked = 0.
kernel/spinlock.c:66:  // On RISC-V, sync_lock_release turns into an atomic swap:
kernel/spinlock.c:67:  //   s1 = &lk->locked
kernel/spinlock.c:69:  __sync_lock_release(&lk->locked);
kernel/spinlock.c:80:  r = (lk->locked && lk->cpu == mycpu());
kernel/spinlock.c:94:  if(mycpu()->noff == 0)
kernel/spinlock.c:95:    mycpu()->intena = old;
kernel/spinlock.c:96:  mycpu()->noff += 1;
kernel/spinlock.c:104:    panic("pop_off - interruptible");
kernel/spinlock.c:105:  if(c->noff < 1)
kernel/spinlock.c:107:  c->noff -= 1;
kernel/spinlock.c:108:  if(c->noff == 0 && c->intena)
kernel/start.c:13:// a scratch area per CPU for machine-mode timer interrupts.
kernel/start.c:16:// assembly code in kernelvec.S for machine-mode timer interrupt.
kernel/start.c:30:  // requires gcc -mcmodel=medany
kernel/start.c:80:  // set the machine-mode trap handler.
kernel/start.c:83:  // enable machine-mode interrupts.
kernel/start.c:86:  // enable machine-mode timer interrupts.
kernel/string.c:21:  while(n-- > 0){
kernel/string.c:23:      return *s1 - *s2;
kernel/string.c:44:    while(n-- > 0)
kernel/string.c:45:      *--d = *--s;
kernel/string.c:47:    while(n-- > 0)
kernel/string.c:64:    n--, p++, q++;
kernel/string.c:67:  return (uchar)*p - (uchar)*q;
kernel/string.c:76:  while(n-- > 0 && (*s++ = *t++) != 0)
kernel/string.c:78:  while(n-- > 0)
kernel/string.c:83:// Like strncpy but guaranteed to NUL-terminate.
kernel/string.c:92:  while(--n > 0 && (*s++ = *t++) != 0)
kernel/syscall.c:16:  if(addr >= p->sz || addr+sizeof(uint64) > p->sz)
kernel/syscall.c:17:    return -1;
kernel/syscall.c:18:  if(copyin(p->pagetable, (char *)ip, addr, sizeof(*ip)) != 0)
kernel/syscall.c:19:    return -1;
kernel/syscall.c:23:// Fetch the nul-terminated string at addr from the current process.
kernel/syscall.c:24:// Returns length of string, not including nul, or -1 for error.
kernel/syscall.c:29:  int err = copyinstr(p->pagetable, buf, addr, max);
kernel/syscall.c:41:    return p->trapframe->a0;
kernel/syscall.c:43:    return p->trapframe->a1;
kernel/syscall.c:45:    return p->trapframe->a2;
kernel/syscall.c:47:    return p->trapframe->a3;
kernel/syscall.c:49:    return p->trapframe->a4;
kernel/syscall.c:51:    return p->trapframe->a5;
kernel/syscall.c:54:  return -1;
kernel/syscall.c:57:// Fetch the nth 32-bit system call argument.
kernel/syscall.c:75:// Fetch the nth word-sized system call argument as a null-terminated string.
kernel/syscall.c:77:// Returns string length if OK (including nul), -1 if error.
kernel/syscall.c:83:    return -1;
kernel/syscall.c:143:  num = p->trapframe->a7;
kernel/syscall.c:145:    p->trapframe->a0 = syscalls[num]();
kernel/syscall.c:148:            p->pid, p->name, num);
kernel/syscall.c:149:    p->trapframe->a0 = -1;
kernel/sysfile.c:2:// File-system system calls.
kernel/sysfile.c:19:// Fetch the nth word-sized system call argument as a file descriptor
kernel/sysfile.c:28:    return -1;
kernel/sysfile.c:29:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
kernel/sysfile.c:30:    return -1;
kernel/sysfile.c:47:    if(p->ofile[fd] == 0){
kernel/sysfile.c:48:      p->ofile[fd] = f;
kernel/sysfile.c:52:  return -1;
kernel/sysfile.c:62:    return -1;
kernel/sysfile.c:64:    return -1;
kernel/sysfile.c:77:    return -1;
kernel/sysfile.c:89:    return -1;
kernel/sysfile.c:101:    return -1;
kernel/sysfile.c:102:  myproc()->ofile[fd] = 0;
kernel/sysfile.c:114:    return -1;
kernel/sysfile.c:126:    return -1;
kernel/sysfile.c:131:    return -1;
kernel/sysfile.c:135:  if(ip->type == T_DIR){
kernel/sysfile.c:138:    return -1;
kernel/sysfile.c:141:  ip->nlink++;
kernel/sysfile.c:148:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
kernel/sysfile.c:161:  ip->nlink--;
kernel/sysfile.c:165:  return -1;
kernel/sysfile.c:175:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
kernel/sysfile.c:193:    return -1;
kernel/sysfile.c:198:    return -1;
kernel/sysfile.c:211:  if(ip->nlink < 1)
kernel/sysfile.c:213:  if(ip->type == T_DIR && !isdirempty(ip)){
kernel/sysfile.c:221:  if(ip->type == T_DIR){
kernel/sysfile.c:222:    dp->nlink--;
kernel/sysfile.c:227:  ip->nlink--;
kernel/sysfile.c:238:  return -1;
kernel/sysfile.c:255:    if(type == T_FILE && (ip->type == T_FILE || ip->type == T_DEVICE))
kernel/sysfile.c:261:  if((ip = ialloc(dp->dev, type)) == 0)
kernel/sysfile.c:265:  ip->major = major;
kernel/sysfile.c:266:  ip->minor = minor;
kernel/sysfile.c:267:  ip->nlink = 1;
kernel/sysfile.c:271:    dp->nlink++;  // for ".."
kernel/sysfile.c:273:    // No ip->nlink++ for ".": avoid cyclic ref count.
kernel/sysfile.c:274:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
kernel/sysfile.c:278:  if(dirlink(dp, name, ip->inum) < 0)
kernel/sysfile.c:296:    return -1;
kernel/sysfile.c:304:      return -1;
kernel/sysfile.c:309:      return -1;
kernel/sysfile.c:312:    if(ip->type == T_DIR && omode != O_RDONLY){
kernel/sysfile.c:315:      return -1;
kernel/sysfile.c:319:  if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
kernel/sysfile.c:322:    return -1;
kernel/sysfile.c:330:    return -1;
kernel/sysfile.c:333:  if(ip->type == T_DEVICE){
kernel/sysfile.c:334:    f->type = FD_DEVICE;
kernel/sysfile.c:335:    f->major = ip->major;
kernel/sysfile.c:337:    f->type = FD_INODE;
kernel/sysfile.c:338:    f->off = 0;
kernel/sysfile.c:340:  f->ip = ip;
kernel/sysfile.c:341:  f->readable = !(omode & O_WRONLY);
kernel/sysfile.c:342:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
kernel/sysfile.c:344:  if((omode & O_TRUNC) && ip->type == T_FILE){
kernel/sysfile.c:363:    return -1;
kernel/sysfile.c:383:    return -1;
kernel/sysfile.c:400:    return -1;
kernel/sysfile.c:403:  if(ip->type != T_DIR){
kernel/sysfile.c:406:    return -1;
kernel/sysfile.c:409:  iput(p->cwd);
kernel/sysfile.c:411:  p->cwd = ip;
kernel/sysfile.c:423:    return -1;
kernel/sysfile.c:454:  return -1;
kernel/sysfile.c:466:    return -1;
kernel/sysfile.c:468:    return -1;
kernel/sysfile.c:469:  fd0 = -1;
kernel/sysfile.c:472:      p->ofile[fd0] = 0;
kernel/sysfile.c:475:    return -1;
kernel/sysfile.c:477:  if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
kernel/sysfile.c:478:     copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
kernel/sysfile.c:479:    p->ofile[fd0] = 0;
kernel/sysfile.c:480:    p->ofile[fd1] = 0;
kernel/sysfile.c:483:    return -1;
kernel/sysproc.c:16:    return -1;
kernel/sysproc.c:24:  return myproc()->pid;
kernel/sysproc.c:38:    return -1;
kernel/sysproc.c:49:    return -1;
kernel/sysproc.c:50:  addr = myproc()->sz;
kernel/sysproc.c:52:    return -1;
kernel/sysproc.c:63:    return -1;
kernel/sysproc.c:66:  while(ticks - ticks0 < n){
kernel/sysproc.c:67:    if(myproc()->killed){
kernel/sysproc.c:69:      return -1;
kernel/sysproc.c:83:    return -1;
kernel/sysproc.c:107:    return -1;
kernel/sysproc.c:108:  myproc()->tickets = n;
kernel/sysproc.c:119:    return -1;
kernel/sysproc.c:129:  if(copyout(myproc()->pagetable, addr, (char *) &ps, sizeof(struct pstat)) < 0)
kernel/sysproc.c:130:    return -1;
kernel/trap.c:51:  p->trapframe->epc = r_sepc();
kernel/trap.c:56:    if(p->killed)
kernel/trap.c:57:      exit(-1);
kernel/trap.c:61:    p->trapframe->epc += 4;
kernel/trap.c:71:    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
kernel/trap.c:73:    p->killed = 1;
kernel/trap.c:76:  if(p->killed)
kernel/trap.c:77:    exit(-1);
kernel/trap.c:100:  w_stvec(TRAMPOLINE + (uservec - trampoline));
kernel/trap.c:103:  // the process next re-enters the kernel.
kernel/trap.c:104:  p->trapframe->kernel_satp = r_satp();         // kernel page table
kernel/trap.c:105:  p->trapframe->kernel_sp = p->kstack + PGSIZE; // process's kernel stack
kernel/trap.c:106:  p->trapframe->kernel_trap = (uint64)usertrap;
kernel/trap.c:107:  p->trapframe->kernel_hartid = r_tp();         // hartid for cpuid()
kernel/trap.c:119:  w_sepc(p->trapframe->epc);
kernel/trap.c:122:  uint64 satp = MAKE_SATP(p->pagetable);
kernel/trap.c:127:  uint64 fn = TRAMPOLINE + (userret - trampoline);
kernel/trap.c:153:  if(which_dev == 2 && myproc() != 0 && myproc()->state == RUNNING)
kernel/trap.c:204:    // software interrupt from a machine-mode timer interrupt,
kernel/uart.c:2:// low-level driver routines for 16550a UART.
kernel/uart.c:13:// the UART control registers are memory-mapped
kernel/uart.c:67:  // leave set-baud mode,
kernel/uart.c:136:// called from both the top- and bottom-half.
kernel/uart.c:164:// return -1 if none is waiting.
kernel/uart.c:172:    return -1;
kernel/uart.c:185:    if(c == -1)
kernel/virtio.h:8:// https://docs.oasis-open.org/virtio/virtio/v1.1/virtio-v1.1.pdf
kernel/virtio.h:19:#define VIRTIO_MMIO_GUEST_PAGE_SIZE	0x028 // page size for PFN, write-only
kernel/virtio.h:20:#define VIRTIO_MMIO_QUEUE_SEL		0x030 // select queue, write-only
kernel/virtio.h:21:#define VIRTIO_MMIO_QUEUE_NUM_MAX	0x034 // max size of current queue, read-only
kernel/virtio.h:22:#define VIRTIO_MMIO_QUEUE_NUM		0x038 // size of current queue, write-only
kernel/virtio.h:23:#define VIRTIO_MMIO_QUEUE_ALIGN		0x03c // used ring alignment, write-only
kernel/virtio.h:26:#define VIRTIO_MMIO_QUEUE_NOTIFY	0x050 // write-only
kernel/virtio.h:27:#define VIRTIO_MMIO_INTERRUPT_STATUS	0x060 // read-only
kernel/virtio.h:28:#define VIRTIO_MMIO_INTERRUPT_ACK	0x064 // write-only
kernel/virtio.h:38:#define VIRTIO_BLK_F_RO              5	/* Disk is read-only */
kernel/virtio.h:89:// the block, and a one-byte status.
kernel/virtio_disk.c:6:// qemu ... -drive file=fs.img,if=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0
kernel/virtio_disk.c:27:  // two contiguous pages of page-aligned physical memory.
kernel/virtio_disk.c:33:  // https://docs.oasis-open.org/virtio/virtio/v1.1/virtio-v1.1.pdf
kernel/virtio_disk.c:56:  // our own book-keeping.
kernel/virtio_disk.c:60:  // track info about in-flight operations,
kernel/virtio_disk.c:69:  // one-for-one with descriptors, for convenience.
kernel/virtio_disk.c:128:  // desc = pages -- num * virtq_desc
kernel/virtio_disk.c:129:  // avail = pages + 0x40 -- 2 * uint16, then num * uint16
kernel/virtio_disk.c:130:  // used = pages + 4096 -- 2 * uint16, then num * vRingUsedElem
kernel/virtio_disk.c:143:// find a free descriptor, mark it non-free, return its index.
kernel/virtio_disk.c:153:  return -1;
kernel/virtio_disk.c:197:      return -1;
kernel/virtio_disk.c:206:  uint64 sector = b->blockno * (BSIZE / 512);
kernel/virtio_disk.c:212:  // data, one for a 1-byte status result.
kernel/virtio_disk.c:224:  // qemu's virtio-blk.c reads them.
kernel/virtio_disk.c:229:    buf0->type = VIRTIO_BLK_T_OUT; // write the disk
kernel/virtio_disk.c:231:    buf0->type = VIRTIO_BLK_T_IN; // read the disk
kernel/virtio_disk.c:232:  buf0->reserved = 0;
kernel/virtio_disk.c:233:  buf0->sector = sector;
kernel/virtio_disk.c:240:  disk.desc[idx[1]].addr = (uint64) b->data;
kernel/virtio_disk.c:243:    disk.desc[idx[1]].flags = 0; // device reads b->data
kernel/virtio_disk.c:245:    disk.desc[idx[1]].flags = VRING_DESC_F_WRITE; // device writes b->data
kernel/virtio_disk.c:256:  b->disk = 1;
kernel/virtio_disk.c:260:  disk.avail->ring[disk.avail->idx % NUM] = idx[0];
kernel/virtio_disk.c:265:  disk.avail->idx += 1; // not % NUM ...
kernel/virtio_disk.c:272:  while(b->disk == 1) {
kernel/virtio_disk.c:297:  // the device increments disk.used->idx when it
kernel/virtio_disk.c:300:  while(disk.used_idx != disk.used->idx){
kernel/virtio_disk.c:302:    int id = disk.used->ring[disk.used_idx % NUM].id;
kernel/virtio_disk.c:308:    b->disk = 0;   // disk is done with buf
kernel/vm.c:18:// Make a direct-map page table for the kernel.
kernel/vm.c:36:  // map kernel text executable and read-only.
kernel/vm.c:37:  kvmmap(kpgtbl, KERNBASE, KERNBASE, (uint64)etext-KERNBASE, PTE_R | PTE_X);
kernel/vm.c:40:  kvmmap(kpgtbl, (uint64)etext, (uint64)etext, PHYSTOP-(uint64)etext, PTE_R | PTE_W);
kernel/vm.c:70:// create any required page-table pages.
kernel/vm.c:72:// The risc-v Sv39 scheme has three levels of page-table
kernel/vm.c:73:// pages. A page-table page contains 512 64-bit PTEs.
kernel/vm.c:74:// A 64-bit virtual address is split into five fields:
kernel/vm.c:75://   39..63 -- must be zero.
kernel/vm.c:76://   30..38 -- 9 bits of level-2 index.
kernel/vm.c:77://   21..29 -- 9 bits of level-1 index.
kernel/vm.c:78://   12..20 -- 9 bits of level-0 index.
kernel/vm.c:79://    0..11 -- 12 bits of byte offset within the page.
kernel/vm.c:86:  for(int level = 2; level > 0; level--) {
kernel/vm.c:135:// be page-aligned. Returns 0 on success, -1 if walk() couldn't
kernel/vm.c:136:// allocate a needed page-table page.
kernel/vm.c:147:  last = PGROUNDDOWN(va + size - 1);
kernel/vm.c:150:      return -1;
kernel/vm.c:163:// page-aligned. The mappings must exist.
kernel/vm.c:247:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
kernel/vm.c:257:    int npages = (PGROUNDUP(oldsz) - PGROUNDUP(newsz)) / PGSIZE;
kernel/vm.c:264:// Recursively free page-table pages.
kernel/vm.c:273:      // this PTE points to a lower-level page table.
kernel/vm.c:285:// then free page-table pages.
kernel/vm.c:298:// returns 0 on success, -1 on failure.
kernel/vm.c:327:  return -1;
kernel/vm.c:345:// Return 0 on success, -1 on error.
kernel/vm.c:355:      return -1;
kernel/vm.c:356:    n = PGSIZE - (dstva - va0);
kernel/vm.c:359:    memmove((void *)(pa0 + (dstva - va0)), src, n);
kernel/vm.c:361:    len -= n;
kernel/vm.c:370:// Return 0 on success, -1 on error.
kernel/vm.c:380:      return -1;
kernel/vm.c:381:    n = PGSIZE - (srcva - va0);
kernel/vm.c:384:    memmove(dst, (void *)(pa0 + (srcva - va0)), n);
kernel/vm.c:386:    len -= n;
kernel/vm.c:393:// Copy a null-terminated string from user to kernel.
kernel/vm.c:396:// Return 0 on success, -1 on error.
kernel/vm.c:407:      return -1;
kernel/vm.c:408:    n = PGSIZE - (srcva - va0);
kernel/vm.c:412:    char *p = (char *) (pa0 + (srcva - va0));
kernel/vm.c:421:      --n;
kernel/vm.c:422:      --max;
kernel/vm.c:432:    return -1;
